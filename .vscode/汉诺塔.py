# 汉诺塔移动模拟
# 汉诺塔来源于印度传说的一个故事，上帝创造世界时作了三根金刚石柱子，在一根柱子上从上往下从小到大顺序摞着64片黄金圆盘。
# 上帝命令婆罗门把圆盘从下面开始按大小顺序重新摆放在另一根柱子上。
# 并且规定，在小圆盘上不能放大圆盘，在三根柱子之间一回只能移动一个圆盘，只能移动在最顶端的圆盘。
"""
通过递归解决首先有ABC三根柱子。先假设A为源柱子，B为辅助柱子。C为目标柱子，n为圆盘的数量
n=1 那么移动方法就是A---C
n=2 移动步骤 
    A---B 整体到B
    A---C 最大那个到C
    B---C 整体到C上面
n>=2以后，都将(除了最大的那个以外的所有圆盘)当成整体。记住源，目标 和辅助。

1、注意限制。汉诺塔问题的核心是倒着来，也就是说要解决大盘子的问题。因为小盘子可以随意放，大盘子有限制。
所以倒着来想，最大的那个盘子就是第一个要解决的问题。解决完，第二大的盘子就是要解决的问题。
所以，你可以假设：最大的盘子是一块，其余盘子是一体的、一块的。
2、三根柱子最后的柱子是目标，也就是相对最大的盘子要依次放在上面。
那么第二根柱子是什么？是借用的柱子，就好像过小溪，中间的那块石头。
第一根就是原始的要出发的柱子。小盘子全部在借用柱上，大盘子才能到目标柱，你想想是不是。
哪怕是100个盘子，有一步也是：上面99个在借用柱上，哎，你把最大的盘子从出发柱，放到目标柱上。这句话，你仔细品。



def hanoi(n,a,b,c): # 圆盘，源，辅助，目标
    if n == 1:
        print(a+'---'+c)
    else: # n>=2 先从目标移动最上面一个到b，再把下面整体移动到b。怎么移动再分解
        hanoi(n-1,a,c,b) # 注意三个柱子定义变了。
        print(a+'---'+c)
        hanoi(n-1,b,a,c)

hanoi(3,'a','b','c')

# 无论怎么移动就是三部，先移动上面n-1到b，再移动最大的到c，再把上面的n-1移动到c
# 至于上面的n-1怎么移动，同样分成最大的一片和另外的整体。按照相同的步骤，但是注意相对的abc柱子变化了。
# 所以我们定义一个变量，这样这个变量在每一部递归是位置就是相对正确

        