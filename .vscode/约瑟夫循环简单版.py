# 约瑟夫环问题
"""
约瑟夫环问题：已知n个人（以编号1，2，3…n分别表示）围坐在一张圆桌周围。
从编号为1的人开始报数，数到k的那个人被杀掉；他的下一个人又从1开始报数，
数到k的那个人又被杀掉；依此规律重复下去，直到圆桌周围的人只剩最后一个。

该写法循环次数较多。以为每次循环都把非删除元素又加到新列表。但是该方法最好理解
"""

def josephus(n,k):
    # 先将所有人生成一个列表,元素值从1开始，下标从0开始
    ls = [i for i in range(1,n+1)]
    # 先定义一个计数器,然后让其在列表里面开始循环
    count = 0
    if n == 1:
        return 1
    else:
        while 1:
            # 计数器从1开始数
            count += 1
            # 开始计数后第一项移除并且准备添加到最后,下面这个赋值运算，先进行pop移除操作。并且返回值给temp。此时ls已经少了一项
            # 这里有个技巧，每次循环开始都添加了 ls.pop(0)这是因为上次循环删除了第一项，每次pop(0)都依次在变化。
            temp = ls.pop(0)
            if count ==3:
                # 数到3（从1开始的）计数器置零。continue代表当前循环停止，开始下一次循环
                count =0
                # print(f'被淘汰的是{temp}')
                continue
            # 如果不是第三项，那么依次将前面数到的加到数列后面去
            ls.append(temp)
            # 最后循环到只有一项时，就是最后剩下的那个人
            if len(ls) == 1:
                print(ls[0])
                break

josephus(21,3)
